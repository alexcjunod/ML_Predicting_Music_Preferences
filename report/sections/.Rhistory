geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Danceability vs AvgSegDuration",
x = "Danceability", y = "AvgSegDuration")
# Create a cloud plot for Acousticness vs Energy with a regression line
ggplot(df_numeric, aes(x = Speechiness, y = Explicit)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Speechiness vs Explicit",
x = "Speechiness", y = "Explicit")
# Create a cloud plot for Acousticness vs Energy with a regression line
ggplot(df_numeric, aes(x = Energy, y = Loudness)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Energy vs Loudness",
x = "Energy", y = "Loudness")
# Create a cloud plot for Danceability vs AvgSegDuration with a regression line
ggplot(df_numeric, aes(x = Instrumentalness, y = ArtistPopularity)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Instrumentalness vs ArtistPopularity",
x = "Instrumentalness", y = "ArtistPopularity")
summary(df_clean)
df_clean_path <- here::here("data", "df_clean")
write.csv(df_clean, df_clean_path, row.names = FALSE)
# Assuming df_clean is your data frame
numeric_columns <- names(df_clean)[sapply(df_clean, is.numeric) & names(df_clean) != "Liked"]
# Initialize a data frame to store the results
results <- data.frame(variable = character(),
mean_difference = numeric(),
p_value = numeric(),
stringsAsFactors = FALSE)
# Loop through each numeric variable to calculate delta and perform t-test
for (col in numeric_columns) {
# Subset data by Liked status
liked_data <- df_clean[df_clean$Liked == 1, col, drop = FALSE]
disliked_data <- df_clean[df_clean$Liked == 0, col, drop = FALSE]
# Calculate mean difference
mean_diff <- abs(mean(liked_data[[col]], na.rm = TRUE) - mean(disliked_data[[col]], na.rm = TRUE))
# Perform t-test
t_test_result <- t.test(liked_data[[col]], disliked_data[[col]], var.equal = TRUE)
# Store results
results <- rbind(results, data.frame(variable = col,
mean_difference = mean_diff,
p_value = t_test_result$p.value))
}
# Order results by mean difference and p-value
results <- results %>%
arrange(desc(mean_difference)) %>%
mutate(rank_mean_diff = row_number())
results <- results %>%
arrange(p_value) %>%
mutate(rank_p_value = row_number())
# Top 5 by mean difference
top_mean_diff <- results %>%
arrange(desc(mean_difference)) %>%
slice_head(n = 5)
# Top 5 by p-value (most statistically significant)
top_p_value <- results %>%
arrange(p_value) %>%
slice_head(n = 5)
# Print results
print("Top 5 variables by mean difference:")
print(top_mean_diff)
print("Top 5 variables by statistical significance:")
print(top_p_value)
# Columns to compare
columns_to_compare <- c('Energy', 'Danceability', 'Duration', 'Instrumentalness',
'Liveness', 'Acousticness', 'Speechiness', 'Tempo',
'TrackPopularity', 'Valence')
# Calculating means for each column grouped by Liked status
means_data <- df_clean %>%
pivot_longer(cols = columns_to_compare, names_to = "Characteristic", values_to = "Value") %>%
group_by(Liked, Characteristic) %>%
summarise(Mean = mean(Value, na.rm = TRUE), .groups = 'drop')
# Map numeric values to labels for clarity in the plot
means_data$Liked <- factor(means_data$Liked, levels = c(0, 1), labels = c("Disliked", "Liked"))
# Creating a combined horizontal bar plot with facets for each characteristic
plot <- ggplot(means_data, aes(x = Mean, y = Liked, fill = Liked)) +
geom_bar(stat = "identity", position = position_dodge(), height = 0.5) +
facet_wrap(~ Characteristic, scales = "free_x") +
labs(title = "Mean Values of Song Characteristics by Liked Status",
x = "Mean Value", y = "Liked Status") +
theme_minimal() +
scale_fill_manual(values = c("#3C6E71", "#FE4A49"), labels = c("Disliked", "Liked")) +
theme(legend.title = element_blank(),  # Removes the legend title
axis.title.y = element_blank(),  # Removes the Y-axis title
plot.title = element_text(size = 16, face = "bold"),  # Bolder plot title
strip.background = element_blank(),  # Removes the background of the facet labels
strip.text = element_text(face = "bold"))  # Bolder facet labels
print(plot)
numeric_columns <- names(df_clean)[sapply(df_clean, is.numeric) & names(df_clean) != "Liked"]
# Initialize a data frame to store the results
results <- data.frame(variable = character(),
mean_difference = numeric(),
p_value = numeric(),
stringsAsFactors = FALSE)
# Function to standardize data (mean = 0, SD = 1)
standardize <- function(x) {
return((x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
}
# Loop through each numeric variable to standardize, calculate delta, and perform t-test
for (col in numeric_columns) {
# Standardize data
df_clean[[col]] <- standardize(df_clean[[col]])
# Subset data by Liked status
liked_data <- df_clean[df_clean$Liked == 1, col, drop = FALSE]
disliked_data <- df_clean[df_clean$Liked == 0, col, drop = FALSE]
# Calculate mean difference
mean_diff <- abs(mean(liked_data[[col]], na.rm = TRUE) - mean(disliked_data[[col]], na.rm = TRUE))
# Perform t-test
t_test_result <- t.test(liked_data[[col]], disliked_data[[col]], var.equal = TRUE)
# Store results
results <- rbind(results, data.frame(variable = col,
mean_difference = mean_diff,
p_value = t_test_result$p.value))
}
# Order results by mean difference and p-value
results <- results %>%
arrange(desc(mean_difference)) %>%
mutate(rank_mean_diff = row_number())
results <- results %>%
arrange(p_value) %>%
mutate(rank_p_value = row_number())
# Top 5 by mean difference
top_mean_diff <- results %>%
arrange(desc(mean_difference)) %>%
slice_head(n = 5)
# Top 5 by p-value (most statistically significant)
top_p_value <- results %>%
arrange(p_value) %>%
slice_head(n = 5)
# Print results
print("Top 5 variables by mean difference:")
print(top_mean_diff)
print("Top 5 variables by statistical significance:")
print(top_p_value)
source(here::here("src/setup.R"))
df_clean <- here::here("data", "df_clean")
df_clean <- read_csv(df_clean)
top_tracks <- df_clean %>%
arrange(desc(TrackPopularity)) %>%  # Sort by descending order of popularity
select(SongName, ArtistName, TrackPopularity, Liked) %>%  # Select relevant columns
head(10)  # Get the top 10 tracks
# Create a gt table
top_tracks_table <- gt(top_tracks) %>%
tab_header(
title = "Top 10 Tracks",
subtitle = "Sorted by Track Popularity"
) %>%
cols_label(
SongName = "Song Name",
ArtistName = "Artist Name",
TrackPopularity = "Popularity",
Liked = "Liked by User"
) %>%
fmt_number(
columns = vars(TrackPopularity),
decimals = 0
) %>%
tab_style(
style = list(
cell_text(weight = "bold"),
cell_fill(color = "lightgray")
),
locations = cells_column_labels(columns = TRUE)
) %>%
tab_options(
table.font.size = px(12),
column_labels.font.size = px(14),
heading.title.font.size = px(16),
heading.subtitle.font.size = px(12)
)
# Print the gt table
print(top_tracks_table)
# First, calculate a popularity threshold for the top 20%
popularity_threshold <- quantile(df_clean$TrackPopularity, 0.8)
# Now, filter tracks above this threshold and count by genre
popular_music_by_genre <- df_clean %>%
filter(TrackPopularity >= popularity_threshold) %>%
count(Genre, sort = TRUE)  # Count the number of tracks per genre and sort
# Create a gt table
popular_music_table <- gt(popular_music_by_genre) %>%
tab_header(
title = "Popular Music by Genre",
subtitle = "Tracks Above the Top 20% Popularity Threshold"
) %>%
cols_label(
Genre = "Genre",
n = "Number of Tracks"
) %>%
tab_style(
style = list(
cell_text(weight = "bold"),
cell_fill(color = "lightgray")
),
locations = cells_column_labels(columns = TRUE)
) %>%
tab_options(
table.font.size = px(12),
column_labels.font.size = px(14),
heading.title.font.size = px(16),
heading.subtitle.font.size = px(12)
)
# Print the gt table
print(popular_music_table)
popular_music_table
#| layout-nrow: 2
numeric_data <- df_clean %>%
select(where(is.numeric), Liked)  # Keep 'Liked' and all numeric columns
long_data <- numeric_data %>%
pivot_longer(
cols = -Liked,  # Exclude the Liked column from the transformation
names_to = "variable",  # Name of the new variable column
values_to = "value"  # Name of the new value column
) %>%
mutate(Label = ifelse(Liked == 1, "Liked", "Disliked"))  # Create a label for coloring
# Define custom colors for the plot
custom_colors <- c("Liked" = "#3C6E71", "Disliked" = "#FE4A49")  # Change these hex codes to desired colors
# Determine the split point for the variables
variables <- unique(long_data$variable)
split_point <- ceiling(length(variables) / 2)
first_half <- variables[1:split_point]
second_half <- variables[(split_point + 1):length(variables)]
# Create the boxplot for the first half
p1 <- ggplot(data = filter(long_data, variable %in% first_half), aes(x = Label, y = value, fill = Label)) +
geom_boxplot() +
scale_fill_manual(values = custom_colors) +
facet_wrap(~ variable, scales = "free") +
labs(title = "Distribution of Features by Liked Status (Part 1)", y = "Value", x = "") +
theme_minimal() +
theme(legend.position = "none",
strip.background = element_blank(),
strip.text.x = element_text(size = 10))
# Create the boxplot for the second half
p2 <- ggplot(data = filter(long_data, variable %in% second_half), aes(x = Label, y = value, fill = Label)) +
geom_boxplot() +
scale_fill_manual(values = custom_colors) +
facet_wrap(~ variable, scales = "free") +
labs(title = "Distribution of Features by Liked Status (Part 2)", y = "Value", x = "") +
theme_minimal() +
theme(legend.position = "none",
strip.background = element_blank(),
strip.text.x = element_text(size = 10))
# Print the plots
print(p1)
print(p2)
df_numeric <- df_clean %>%
select(where(is.numeric)) %>%  # Automatically select only numeric columns
mutate(across(everything(), scale))  # Scale all selected numeric columns
# Run PCA
df_pca <- PCA(df_numeric, graph = FALSE)
# Print PCA results
print(df_pca)
# Visualizing PCA: Scree plot to see the variance explained by each principal component
fviz_eig(df_pca, addlabels = TRUE, ncp = 11)  # Adjust 'ncp' as necessary
fviz_pca_var(df_pca)
# Visualizing PCA: Biplot to see loadings and scores
# Enhancing biplot with color coding for Liked/Disliked
liked_status <- df_clean$Liked  # Assuming 'Liked' is the binary indicator
liked_colors <- ifelse(liked_status == 1, "Liked", "Disliked")  # Use direct labels for colors
fviz_pca_biplot(df_pca,
geom = "point",  # Add points
col.ind = liked_colors,  # Color by liked status
addEllipses = FALSE,  # Remove confidence ellipses
legend.title = "Liked Status",
palette = c("Disliked" = "#FE4A49", "Liked" = "#3C6E71"))  # Define the palette if necessary
# Visualize variable contributions to the principal components
fviz_contrib(df_pca, choice = "var", axes = 1)  # For PC1 contributions, change 'axes' for other PCs
fviz_contrib(df_pca, choice = "var", axes = 2)  # For PC2 contributions, change 'axes' for other PCs
#| column: screen-inset-shaded
#| layout-nrow: 8
numeric_columns <- names(df_clean)[sapply(df_clean, is.numeric)]
# Generate plots for each numeric variable
for (col in numeric_columns) {
if (col != "Liked") {
# Calculate averages for each Liked status
averages <- df_clean %>%
group_by(Liked) %>%
summarise(Avg = mean(get(col), na.rm = TRUE)) %>%
mutate(Liked = as.factor(Liked))  # Ensure Liked is a factor for aesthetics
# Combined Histogram and Density Plot with Averages
plot <- ggplot(df_clean, aes_string(x = col, fill = "factor(Liked)")) +
geom_histogram(aes(y = after_stat(density)), fill = "grey", color = "black", bins = 30) +  # Histogram for overall distribution
geom_density(alpha = 0.5, aes(color = factor(Liked), fill = factor(Liked))) +  # Density plots with color
geom_vline(data = averages, aes(xintercept = Avg, color = Liked), linetype = "dashed", size = 1) +  # Average lines
labs(title = paste("Distribution and Comparison of", col, "by Liked Status"),
x = col, y = "Density") +
theme_minimal() +
scale_fill_manual(values = c("#FE4A49", "#3C6E71")) +  # Colors for the fill of density plot
scale_color_manual(values = c("#FE4A49", "#3C6E71")) +  # Colors for the density lines
guides(fill=guide_legend(title="Liked Status"), color=guide_legend(title="Liked Status"))  # Adjust the legend for clarity
# Print the plot
print(plot)
}
}
numeric_columns <- names(df_clean)[sapply(df_clean, is.numeric) & names(df_clean) != "Liked"]
# Initialize a data frame to store the results
results <- data.frame(variable = character(),
mean_difference = numeric(),
p_value = numeric(),
stringsAsFactors = FALSE)
# Function to standardize data (mean = 0, SD = 1)
standardize <- function(x) {
return((x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
}
# Loop through each numeric variable to standardize, calculate delta, and perform t-test
for (col in numeric_columns) {
# Standardize data
df_clean[[col]] <- standardize(df_clean[[col]])
# Subset data by Liked status
liked_data <- df_clean[df_clean$Liked == 1, col, drop = FALSE]
disliked_data <- df_clean[df_clean$Liked == 0, col, drop = FALSE]
# Calculate mean difference
mean_diff <- abs(mean(liked_data[[col]], na.rm = TRUE) - mean(disliked_data[[col]], na.rm = TRUE))
# Perform t-test
t_test_result <- t.test(liked_data[[col]], disliked_data[[col]], var.equal = TRUE)
# Store results
results <- rbind(results, data.frame(variable = col,
mean_difference = mean_diff,
p_value = t_test_result$p.value))
}
# Order results by mean difference and p-value
results <- results %>%
arrange(desc(mean_difference)) %>%
mutate(rank_mean_diff = row_number())
results <- results %>%
arrange(p_value) %>%
mutate(rank_p_value = row_number())
# Top 5 by mean difference
top_mean_diff <- results %>%
arrange(desc(mean_difference)) %>%
slice_head(n = 5)
# Top 5 by p-value (most statistically significant)
top_p_value <- results %>%
arrange(p_value) %>%
slice_head(n = 5)
# Print results
print("Top 5 variables by mean & statistical difference:")
print(top_mean_diff)
# Columns to compare
columns_to_compare <- c('Energy', 'Danceability', 'Duration', 'Instrumentalness',
'Liveness', 'Acousticness', 'Speechiness', 'Tempo',
'TrackPopularity', 'Valence')
# Calculating means for each column grouped by Liked status
means_data <- df_clean %>%
pivot_longer(cols = columns_to_compare, names_to = "Characteristic", values_to = "Value") %>%
group_by(Liked, Characteristic) %>%
summarise(Mean = mean(Value, na.rm = TRUE), .groups = 'drop')
# Map numeric values to labels for clarity in the plot
means_data$Liked <- factor(means_data$Liked, levels = c(0, 1), labels = c("Disliked", "Liked"))
# Creating a combined horizontal bar plot with facets for each characteristic
plot <- ggplot(means_data, aes(x = Mean, y = Liked, fill = Liked)) +
geom_bar(stat = "identity", position = position_dodge(), height = 0.5) +
facet_wrap(~ Characteristic, scales = "free_x") +
labs(title = "Mean Values of Song Characteristics by Liked Status",
x = "Mean Value", y = "Liked Status") +
theme_minimal() +
scale_fill_manual(values = c("#3C6E71", "#FE4A49"), labels = c("Disliked", "Liked")) +
theme(legend.title = element_blank(),  # Removes the legend title
axis.title.y = element_blank(),  # Removes the Y-axis title
plot.title = element_text(size = 16, face = "bold"),  # Bolder plot title
strip.background = element_blank(),  # Removes the background of the facet labels
strip.text = element_text(face = "bold"))  # Bolder facet labels
print(plot)
#| column: screen-inset-shaded
cor_matrix <- cor(df_clean[sapply(df_clean, is.numeric)])  # Compute correlation matrix for numeric columns
corrplot(cor_matrix, method = "color", order = "hclust",
tl.col = "black", tl.srt = 45)  # Text label color and rotation
# Assuming 'df_clean' is your data frame and 'Liked' is included as a numeric column
cor_matrix <- cor(df_clean[sapply(df_clean, is.numeric)])  # Compute correlation matrix for numeric columns
# Flatten the matrix and remove self-correlations
cor_data <- as.data.frame(as.table(cor_matrix))
cor_data <- cor_data[cor_data$Var1 != cor_data$Var2, ]
# Filter out duplicates
cor_data <- cor_data[!duplicated(t(apply(cor_data, 1, sort))), ]
# Sort by the absolute values of correlations to handle both positive and negative
cor_data <- cor_data[order(-abs(cor_data$Freq)), ]
# Top 5 positive correlations
top_positive <- head(cor_data[cor_data$Freq > 0, ], 10)
# Top 5 negative correlations
top_negative <- head(cor_data[cor_data$Freq < 0, ], 10)
# Combine the top positive and negative correlations for display
top_correlations <- rbind(
data.frame(Category = "Positive", top_positive),
data.frame(Category = "Negative", top_negative)
)
# Create a gt table
gt_table <- gt(top_correlations) %>%
tab_header(
title = "Top 5 Positive and Negative Correlations"
) %>%
cols_label(
Category = "Correlation Type",
Var1 = "Variable 1",
Var2 = "Variable 2",
Freq = "Correlation Coefficient"
) %>%
fmt_number(
columns = vars(Freq),
decimals = 2
) %>%
tab_style(
style = list(
cell_fill(color = "#B3B3B3"),
cell_text(weight = "bold")
),
locations = cells_column_labels(columns = TRUE)
) %>%
tab_options(
column_labels.border.bottom.color = "black"
)
# Print the gt table
print(gt_table)
#| layout-nrow: 2
# Assuming df_clean is your cleaned dataset
df_numeric <- df_clean %>%
select(Acousticness, Energy, Danceability, AvgSegDuration, Speechiness, Explicit, Energy, Loudness, Instrumentalness, ArtistPopularity) %>%
mutate(across(where(is.numeric), scale))  # Scale numeric columns
# Create a cloud plot for Acousticness vs Energy with a regression line
ggplot(df_numeric, aes(x = Acousticness, y = Energy)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Acousticness vs Energy",
x = "Acousticness", y = "Energy")
# Create a cloud plot for Danceability vs AvgSegDuration with a regression line
ggplot(df_numeric, aes(x = Danceability, y = AvgSegDuration)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Danceability vs AvgSegDuration",
x = "Danceability", y = "AvgSegDuration")
# Create a cloud plot for Acousticness vs Energy with a regression line
ggplot(df_numeric, aes(x = Speechiness, y = Explicit)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Speechiness vs Explicit",
x = "Speechiness", y = "Explicit")
# Create a cloud plot for Acousticness vs Energy with a regression line
ggplot(df_numeric, aes(x = Energy, y = Loudness)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Energy vs Loudness",
x = "Energy", y = "Loudness")
# Create a cloud plot for Danceability vs AvgSegDuration with a regression line
ggplot(df_numeric, aes(x = Instrumentalness, y = ArtistPopularity)) +
geom_point(alpha = 0.6) +  # Adjust transparency with alpha
geom_smooth(method = "lm", color = "#1DB954", se = TRUE) +  # Add linear regression line with confidence interval
theme_minimal() +
labs(title = "Cloud Plot of Instrumentalness vs ArtistPopularity",
x = "Instrumentalness", y = "ArtistPopularity")
summary(df_clean)
df_clean_path <- here::here("data", "df_clean")
write.csv(df_clean, df_clean_path, row.names = FALSE)
# Assuming results have been calculated and top_mean_diff and top_p_value have been determined
# Combine top results for presentation in one table
top_results <- top_mean_diff %>%
select(variable, mean_difference) %>%
rename(MeanDifference = mean_difference) %>%
inner_join(top_p_value %>%
select(variable, p_value) %>%
rename(PValue = p_value), by = "variable") %>%
arrange(desc(MeanDifference))
# Create a gt table
gt_table <- gt(top_results) %>%
tab_header(
title = "Top 5 Variables by Mean Difference and Statistical Significance"
) %>%
cols_label(
variable = "Variable",
MeanDifference = "Mean Difference (Standardized)",
PValue = "P-value"
) %>%
fmt_number(
columns = vars(MeanDifference),
decimals = 3
) %>%
fmt_number(
columns = vars(PValue),
decimals = 3
) %>%
tab_options(
heading.background.color = "#D3D3D3",
column_labels.font.size = "larger",
row_group.font.size = "larger"
) %>%
data_color(
columns = vars(MeanDifference),
colors = scales::col_numeric(palette = c("red", "green"), domain = NULL)
) %>%
tab_style(
style = list(
cell_text(weight = "bold"),
cell_fill(color = "lightgray")
),
locations = cells_column_labels(columns = TRUE)
)
# Print the gt table
print(gt_table)
View(df_clean)
View(df_clean)
View(df_clean)
View(df_clean)
source(here::here("src/setup.R"))
reticulate::repl_python()
